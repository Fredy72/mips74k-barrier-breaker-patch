--- ./net/core/skbuff.c	2015-09-30 20:27:46.000000000 +0800
+++ ./net/core/skbuff.c	2015-10-10 11:34:51.023758825 +0800
@@ -146,6 +146,56 @@ out:
 	return obj;
 }
 
+static inline void zero_struct(void *v, int size)
+{
+	uint32_t *s = (uint32_t *)v;
+
+	/* We assume that size is word aligned; in fact, it's constant */
+	BUG_ON((size & 3) != 0);
+
+	/*
+	 * This looks odd but we "know" size is a constant, and so the
+	 * compiler can fold away all of the conditionals.  The compiler is
+	 * pretty smart here, and can fold away the loop, too!
+	 */
+	while (size > 0) {
+		if (size >= 4)
+			s[0] = 0;
+		if (size >= 8)
+			s[1] = 0;
+		if (size >= 12)
+			s[2] = 0;
+		if (size >= 16)
+			s[3] = 0;
+		if (size >= 20)
+			s[4] = 0;
+		if (size >= 24)
+			s[5] = 0;
+		if (size >= 28)
+			s[6] = 0;
+		if (size >= 32)
+			s[7] = 0;
+		if (size >= 36)
+			s[8] = 0;
+		if (size >= 40)
+			s[9] = 0;
+		if (size >= 44)
+			s[10] = 0;
+		if (size >= 48)
+			s[11] = 0;
+		if (size >= 52)
+			s[12] = 0;
+		if (size >= 56)
+			s[13] = 0;
+		if (size >= 60)
+			s[14] = 0;
+		if (size >= 64)
+			s[15] = 0;
+		size -= 64;
+		s += 16;
+	}
+}
+
 /* 	Allocate a new skbuff. We do this ourselves so we can fill in a few
  *	'private' fields and also do memory statistics to find all the
  *	[BEEP] leaks.
@@ -167,7 +217,7 @@ struct sk_buff *__alloc_skb_head(gfp_t g
 	 * actually initialise below. Hence, don't put any more fields after
 	 * the tail pointer in struct sk_buff!
 	 */
-	memset(skb, 0, offsetof(struct sk_buff, tail));
+	zero_struct(skb, 0, offsetof(struct sk_buff, tail));
 	skb->head = NULL;
 	skb->truesize = sizeof(struct sk_buff);
 	atomic_set(&skb->users, 1);
@@ -239,7 +289,7 @@ struct sk_buff *__alloc_skb(unsigned int
 	 * actually initialise below. Hence, don't put any more fields after
 	 * the tail pointer in struct sk_buff!
 	 */
-	memset(skb, 0, offsetof(struct sk_buff, tail));
+	zero_struct(skb, 0, offsetof(struct sk_buff, tail));
 	/* Account for allocated memory : skb + skb->head */
 	skb->truesize = SKB_TRUESIZE(size);
 	skb->pfmemalloc = pfmemalloc;
@@ -255,7 +305,7 @@ struct sk_buff *__alloc_skb(unsigned int
 
 	/* make sure we initialize shinfo sequentially */
 	shinfo = skb_shinfo(skb);
-	memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
+	zero_struct(shinfo, 0, offsetof(struct skb_shared_info, dataref));
 	atomic_set(&shinfo->dataref, 1);
 	kmemcheck_annotate_variable(shinfo->destructor_arg);
 
@@ -309,7 +359,7 @@ struct sk_buff *build_skb(void *data, un
 
 	size -= SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
 
-	memset(skb, 0, offsetof(struct sk_buff, tail));
+	zero_struct(skb, 0, offsetof(struct sk_buff, tail));
 	skb->truesize = SKB_TRUESIZE(size);
 	skb->head_frag = frag_size != 0;
 	atomic_set(&skb->users, 1);
@@ -324,7 +374,7 @@ struct sk_buff *build_skb(void *data, un
 
 	/* make sure we initialize shinfo sequentially */
 	shinfo = skb_shinfo(skb);
-	memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
+	zero_struct(shinfo, 0, offsetof(struct skb_shared_info, dataref));
 	atomic_set(&shinfo->dataref, 1);
 	kmemcheck_annotate_variable(shinfo->destructor_arg);
 
@@ -1226,7 +1276,7 @@ int skb_pad(struct sk_buff *skb, int pad
 
 	/* If the skbuff is non linear tailroom is always zero.. */
 	if (!skb_cloned(skb) && skb_tailroom(skb) >= pad) {
-		memset(skb->data+skb->len, 0, pad);
+		zero_struct(skb->data+skb->len, 0, pad);
 		return 0;
 	}
 
@@ -1244,7 +1294,7 @@ int skb_pad(struct sk_buff *skb, int pad
 	if (unlikely(err))
 		goto free_skb;
 
-	memset(skb->data + skb->len, 0, pad);
+	zero_struct(skb->data + skb->len, 0, pad);
 	return 0;
 
 free_skb:
@@ -3337,7 +3387,7 @@ void skb_tstamp_tx(struct sk_buff *orig_
 		return;
 
 	serr = SKB_EXT_ERR(skb);
-	memset(serr, 0, sizeof(*serr));
+	zero_struct(serr, 0, sizeof(*serr));
 	serr->ee.ee_errno = ENOMSG;
 	serr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
 
@@ -3358,7 +3408,7 @@ void skb_complete_wifi_ack(struct sk_buf
 	skb->wifi_acked = acked;
 
 	serr = SKB_EXT_ERR(skb);
-	memset(serr, 0, sizeof(*serr));
+	zero_struct(serr, 0, sizeof(*serr));
 	serr->ee.ee_errno = ENOMSG;
 	serr->ee.ee_origin = SO_EE_ORIGIN_TXSTATUS;
 
